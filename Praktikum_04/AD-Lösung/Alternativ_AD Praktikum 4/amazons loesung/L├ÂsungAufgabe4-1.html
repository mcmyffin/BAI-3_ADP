<!DOCTYPE html>
<html>
    <head>
		<meta charset="utf-8">
        <title>L&ouml;sungsblatt Aufgabe 4</title>
        <!-- morris graph lib -->
        <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/morris.js/0.5.1/morris.css">
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/morris.js/0.5.1/morris.min.js"></script>
        <!-- LaTeX-style equations -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- tests -->
        <script type="text/javascript">
            function assert(value, desc) {
                var li = document.createElement("li");
                li.style.color = value ? "green" : "red";
                li.appendChild(document.createTextNode(desc));
                var list = document.getElementById("results");
                if (!list) {
                    list = document.createElement("div");
                    document.body.appendChild(list);
                }
                list.appendChild(li);
            }

            function isInt(n){
                return Number(n)===n && n%1===0;
            };

            var Preconditions = {
                checkArgument: function(condition, message) {
                    if (!condition) {
                        throw Error('IllegalArgumentException: ' + (message || ''));
                    }
                }
            };

            var counter = 0;

            function count() {
                counter++;
            }

            function resetCounter() {
                counter = 0;
            }

            function getCounter() {
                return counter;
            }

            var counterTime = 0;
            function countTime() {
                counterTime++;
            }

            function resetCounterTime() {
                counterTime = 0;
            }

            function getCounterTime() {
                return counterTime;
            }
        </script>
    </head>
    <body>
        <h1 id="title">L&ouml;sung Aufgabe 4 <br></br> Alexander Holland,<br />Henning Kahl,<br /> Torben-Dennis Mader,<br /> Jan Dieckhoff,<br /> Konstantin Böhm,<br /> Jonas Johannsen,<br /> Christopher Wolter,<br /> Gerhard Wagner,<br /> Micheal Bernhardt,<br /> Ralf Prediger,<br /> Torben Fischer</h1>
<h2>Aufgabe 1 (Summenpaare)</h2>
<p>
Gegeben sei eine Sequenz S von ganzen Zahlen und eine ganze Zahl K. Zu berechnen ist die
Anzahl der Paare von Elementen (P;Q) aus S für die gilt:
P + Q = K
</p>
<p>
Beispiel: Bei der Eingabe sumPairs([1,5,3,7,2,2],4) existieren 4 Paare => (1,3),(3,1),(2,2),(2,2)
</p>
<h3>
Implementierung
</h3>
<!-- In diesem Element wird der Inhalt des scripts mit der ID ad-1-1-results angezeigt -->
<pre id="ad-1-1-source"></pre>
<h3>
Testergebnisse
</h3>
<div id="ad-1-1-results"></div>

<!-- Code und Tests hier hin -->
<script id="ad-1-1-code">
  var ad_1_1_data = [];

  var counter = 0; // Zählvariable zur Laufzeitmessung
  
  // Code

	function mergeSort (arr) {    
		if (arr.length < 2) return arr;
		
		var mid = Math.floor(arr.length /2);
		var subLeft = mergeSort(arr.slice(0,mid));
		var subRight = mergeSort(arr.slice(mid));
		
		return merge(subLeft, subRight);
	}

	function merge (a,b) {
		var result = [];
		while (a.length >0 && b.length >0)
			result.push(a[0] < b[0]? a.shift() : b.shift());
		return result.concat(a.length? a : b);
	}
  
	/*
		seq, Die zu durchsuchende Sequenz
		value, Der Wert, der überprüft werden soll
		@return Anzahl der summenpaare in seq, aus denen man den value bilden kann. 
	*/
	function sumPairs(seq,value)
	{
		var i=0, result=0;
		var arr = mergeSort(seq);
		var j=arr.length-1;
		// Die erste for-Schleife äuft in O(seq)
		while(i < j){
			counter++;
			var val = arr[i] + arr[j];
			
			if(val == value){
				
				if(arr[i] == arr[j]){
					result++;
				}
				else{
					result+=2;
				}
				
				var k=i;
				while(i<j && arr[k]==arr[i]){
					counter++;
					i++;
				}
			}
			else if(val > value){
				j--;
			}
			else if(val < value){
				i++;
			}
		}
		return result;
	}

        /*****************************TESTS-ANFANG********************************/
	
	var array1 = new Array(10); // Array = [1..10]
	for(var i=0; i < array1.length;i++){
		array1[i] = i+1;
	}
	
	var array2 = new Array(10); // leeres Array
	
	var array3 = new Array(0,0,2,2,3,3,3,5);
	
	var array4 = new Array(5,5,5);
	
	assert(4 == sumPairs(array1,5),"In einem Array [1,2,3,4,5,6,7,8,9,10] gibt es vier Möglichkeiten die 5 zu bilden"); // Test 1 in einem Array mit unterschiedlichen Werten
	assert(2 == sumPairs(array3,3)," In einem Array(0,0,2,2,3,3,3,5), gibt es zwei Möglichkeiten die 3 zu bilden: (0,3),(3,0)"); // Test 2 in einem Array in dem Werte mehrmals vorkommen können
	assert(1 == sumPairs(array4,10), "In einem Array(5,5,5), gibt es nur eine Möglichkeit die 10 zu bilden: (5,5)"); // Test 3 in einem Array, wo nur gleiche Werte stehen
	assert(0 == sumPairs(array1,20),"In einem Array[1,2,3,4,5,6,7,8,9,10] gibt es keine Möglichkeit den Wert 20 zu bilden"); // Test 4 einen zu großen Value wählen	

	
	// Experimente (für Ergebnisse siehe Graph unten)
	for(i = 0; i < 100; i ++)
	{
		var array3 = new Array(i+1); // Array = [1..100]
		for(var i=0; i < array3.length; i++){
			array3[i] = i+1;
		}
		counter=0;
		sumPairs(array3,i+1);
		ad_1_1_data.push({
		  experiment : i+1,
		  value : counter
		  });
	}
	
</script>
<!-- dieser Code zeigt die Implementierung und die Tests an -->
<script>
$('pre#ad-1-1-source').html($('#ad-1-1-code').html())
</script>
<h3>
	Ergebnis: Die Laufzeit ist in O(|S|log(|S|)). Angezeigt wird nur unsere Berechnung, die in O(|S|) erfolgt. Da wir das Array sortieren müssen und dies mittels
			  MergeSort in O(|S|log(|S|)) erfolgt, folgt daraus die Laufzeit von O(|S|log(|S|)).
			  Die Laufzeit ist Abhängig von der Größe des Arrays.
	
			  Da wir nur mit dem einen Array arbeiten, ist der Platzaufwand auch nur in O(|S|).
</h3>
<br />
        <h3>
            Experimente: Zeitaufwand bei der Berechnung der Summenpaare.
        </h3>

<div id="ad-1-1-experiments" style="height: 250px;"></div>
<script>
new Morris.Line({
  // ID of the element in which to draw the chart.
  element: 'ad-1-1-experiments',
  // do values relate to dates (time)?
  parseTime: false,
  // Chart data records -- each entry in this array corresponds to a point on
  // the chart.
  data: ad_1_1_data,
  // The name of the data record attribute that contains x-values.
  xkey: 'experiment',
  // A list of names of data record attributes that contain y-values.
  ykeys: ['value'],
  // Labels for the ykeys -- will be displayed when you hover over the
  // chart.
  labels: ['Value']
});
</script>

        <!-- Aufgabe 2 -->
        <h2>
            &Uuml;bung Aufgabe 4.2 (Mittelpunkte)
        </h2>

            <br>
            Gegeben sei eine Sequenz S von ganzen Zahlen. Zu berechnen ist ein Index i f&uuml;r den gilt,  <br>
            dass die Summe der Elemente links gleich der Summe der Elemente rechts von i ist: <h4>$\sum\nolimits_{0 \leq j < i}$ S[j] = $\sum\nolimits_{i < k < |S|}$ S[k]</h4>
            Der R&uuml;ckgabewert -1 zeigt an, dass es keinen solchen Index gibt. <br>
            Die Implementierung soll in O(|S|) laufen und h&ouml;chstens O(|S|) zus&auml;tzlichen Speicherbedarf haben.
        <h3>
            Implementierung
        </h3>
        <!-- In diesem Element wird der Inhalt des scripts mit der ID ad-1-2-code angezeigt -->
        <pre id="ad-4-2-source"></pre>
        <h3>
            Testergebnisse
        </h3>
        <div id="ad-4-2-results"></div>
        <!-- Code und Tests hier hin -->
        <script id="ad-4-2-code">
            resetCounter();
            resetCounterTime();
            var ad_4_2data = [];
            var ad_4_2_1data = [];

//            function mittelpunkteTime(s) {
//                var start = new Date().getTime();
//                mittelpunkte(s);
//                var end = new Date().getTime();
//                var time = end - start;
//                return time;
//            }

            var testArrayMittelpunkte = [];
            for(var i = 0; i < 100; i ++) {
                testArrayMittelpunkte.push((Math.random() * i) + 1);
                mittelpunkte(testArrayMittelpunkte);
                ad_4_2data.push({
                    experiment : i,
                    value : getCounterTime()
                });
                resetCounterTime();
                mittelpunkteSpace(i,getCounter());
                resetCounter();
            }

            function mittelpunkteSpace(i,space) {
                ad_4_2_1data.push({
                    experiment : i,
                    value : space
                });
            }

            function mittelpunkte(s) {
                Preconditions.checkArgument(Array.isArray(s), 'S ist kein Array');
                if(s.length < 3) {
                    return -1;
                }
				
                var right = 0;          count();
                for(i = 2; i < s.length; i++) {
                    right += s[i];      
                    countTime();
                }
				
                var left = s[0];        count();
                for(i = 1; i < s.length; i++) {
                    if(left == right) {
                        return i;
                    }
                    left += s[i];       
                    right -= s[i+1];    
                    countTime();
                }
                return -1;
            }

            // Tests
            assert(mittelpunkte([1,2,3,5,3,2,1]) === 3, "S=[1,2,3,5,3,2,1] => 3");
            assert(mittelpunkte([1,2,3,5,3,2,1,2,3,3]) === 4, "S=[1,2,3,5,3,2,1,2,3,3] => 4");
            assert(mittelpunkte([-1,-2,-3,5,-3,-2,-1]) === 3, "S=[1,2,3,5,3,2,1] => 3");
            assert(mittelpunkte([-1,-2,-3,5,-6]) === 3, "S=[-1,-2,-3,5,-6] => 3");
            assert(mittelpunkte([1,1,1]) === 1, "S=[1,1,1] => 1");
            assert(mittelpunkte([0,0,0,0,0,0,0,0]) === 1, "S=[0,0,0,0,0,0,0,0] => 1");

            assert(mittelpunkte([]) === -1, "S=[] => -1");
            assert(mittelpunkte([1]) === -1, "S=[1] => -1");
            assert(mittelpunkte([1,2]) === -1, "S=[1,2] => -1");
            assert(mittelpunkte([1,2,3,5,5,2,1]) === -1, "S=[1,2,3,5,5,2,1] => -1");
            assert(mittelpunkte([-1,-2,-3,5,1,2,3]) === -1, "S=[-1,-2,-3,5,1,2,3] => -1");

            assert(typeof(mittelpunkte) === 'function', "function 'mittelpunkte' not implemented");
        </script>
        <!-- dieser Code zeigt die Implementierung und die Tests an -->
        <script>
            $('pre#ad-4-2-source').html($('#ad-4-2-code').html())
        </script>
		
		       <h3> Die Laufzeit ist in O(|S|) und abhängig von der Größe des Arrays. Der Platzbetrag ist in O(1), da wir nur mit zwei Variablen arbeiten müssen. </h3>
			   <br />
        <h3>
            Experimente: Zeitaufwand bei der Berechnung der Mittelpunkte.
        </h3>

        <div id="ad-4-2-experiments" style="height: 250px;"></div>
        <script>
            new Morris.Line({
                // ID of the element in which to draw the chart.
                element: 'ad-4-2-experiments',
                // do values relate to dates (time)?
                parseTime: false,
                // Chart data records -- each entry in this array corresponds to a point on
                // the chart.
                data: ad_4_2data,
                // The name of the data record attribute that contains x-values.
                xkey: 'experiment',
                // A list of names of data record attributes that contain y-values.
                ykeys: ['value'],
                // Labels for the ykeys -- will be displayed when you hover over the
                // chart.
                labels: ['Ben&ouml;tigte Zeit']
            });
        </script>

        <!-- Aufgabe 3 -->
        <h2>
            &Uuml;bung Aufgabe 4.3 (L&auml;ngste Pfade ohne Richtungswechsel)
        </h2>
        <br>
        Gegeben sei ein bin&auml;rer Baum T = (V, E) und die Funktionen r, l : V $\rightarrow$ V $\cup$ {nil},<br>
        die zu einem Knoten das jeweils rechte oder linke Kind bestimmen (nil bedeutet, dass der Knoten kein rechtes bzw. linkes Kind hat).<br>
        Zu berechnen ist die maximale Distanz zwischen den Knoten $v_{0}$, $v_{n}$ f&uuml;r die gilt, <br>
        dass sie auf einem Pfad von der Wurzel des Baums zu einem Blatt liegen und zus&auml;tzlich gilt <br>
        <h4>$\forall i : 0 \leq i < n \circ l(v_{i}) in (v_{0},...,v_{n})$ oder $\forall i : 0 \leq i < n \circ r(v_{i}) in (v_{0},...,v_{n})$ </h4>
        Die Implementierung soll in O(V) laufen und h&ouml;chstens O(V) zus&auml;tzlichen Speicherbedarf haben.
        <h3>
            Implementierung
        </h3>
        <!-- In diesem Element wird der Inhalt des scripts mit der ID ad-1-2-code angezeigt -->
        <pre id="ad-4-3-source"></pre>
        <h3>
            Testergebnisse
        </h3>
        <div id="ad-4-3-results"></div>
        <!-- Code und Tests hier hin -->
        <script id="ad-4-3-code">
            resetCounter();
            resetCounterTime();
            var ad_4_3data = [];
            var ad_4_3_1data = [];

//            function findLongesPathWithoutDirectionChangeTime(tree) {
//                var start = new Date().getTime();
//                tree.findLongesPathWithoutDirectionChange();
//                var end = new Date().getTime();
//                var time = end - start;
//                return time;
//            }

            var testTree = new Tree();
            for(var i = 0; i < 100; i ++) {
                testTree.insert((Math.random() * i) + 1);
                findLongestPath(testTree,0,null);
                ad_4_3data.push({
                    experiment : i,
                    value : getCounterTime()
                });
                resetCounterTime();
                findLongesPathWithoutDirectionChangeSpace(i,getCounter());
                resetCounter();
            }
//
            function findLongesPathWithoutDirectionChangeSpace(i,space) {
                ad_4_3_1data.push({
                    experiment : i,
                    value : space
                });
            }

            function Tree() {
                this.constructor = Tree;
                this.key = new Key();
                this.left = null;
                this.right = null;
//                this.pathWithoutDirectionChange = 0;
                this.directionParent = null;
                this.empty = empty;
                this.insert = insert;
            }

            function insert(key) {
                if(this.empty()) {
                    this.key.setKey(key);
                } else if(this.key.compare(key) < 0) {
                    if(this.right == null) {
                        this.right = new Tree();
                        this.right.insert(key);
                    } else {
                        this.right.insert(key);
                    }
                } else {
                    if(this.left == null) {
                        this.left = new Tree();
                        this.left.insert(key);
                    } else {
                        this.left.insert(key);
                    }
                }
            }

            function findLongestPath(node,length,direction) {
                var lengthLeft = 1;                 count();
                var lengthRight = 1;                count();
                var maxLeft = 0;                    count();
                var maxRight = 0;                   count();
                if(direction == "left") {
                    lengthLeft = length +1;
                } else if (direction == "right"){
                    lengthRight = length +1;
                }
                if(node.left != null) {
                    maxLeft = findLongestPath(node.left,lengthLeft,"left");
                }
                if(node.right != null) {
                    maxRight = findLongestPath(node.right,lengthRight,"right");
                }
                if(maxLeft > maxRight) {
                    if(maxLeft > length) {
                        length = maxLeft;
                    }
                } else {
                    if(maxRight > length) {
                        length = maxRight;
                    }
                }
                countTime();
                return length;
            }

            function empty() {
              if(this.key.getKey() == null) {
                  return true;
              } else {
                  return false;
              }
            }

            function Key(key) {
                this.constructor = Key;
                this.key = key;
                this.getKey = getKey;
                this.setKey = setKey;
                this.compare = compare;
            }

            function getKey() {
                return this.key;
            }

            function setKey(key) {
                if(this.key == null) {
                    this.key = key;
                    return true;
                } else {
                    return false;
                }
            }

            function compare(other_key) {
                if (this.key < other_key) {
                    return -1;
                } else if (this.key > other_key) {
                    return 1;
                }
                return 0;
            }

			//                 10
			//            /         \
			//          6             14
			//       /     \        /    \
			//      3       8     12      15
			//    /   \   /   \     \       \
			//   2     5 7     9    13       16
			//                                 \
			//                                 17
            var tree = new Tree();          	
            tree.insert(10);                	
            tree.insert(6);                 	
            tree.insert(3);					
            tree.insert(8);					
            tree.insert(2);					
            tree.insert(5);					
            tree.insert(7);					
            tree.insert(9);					
            tree.insert(14);
            tree.insert(12);
            tree.insert(15);
            tree.insert(13);
            tree.insert(16);
            tree.insert(17);

			//                 10
			//            /         \
			//          6             14
			//       /     \        /    \
			//      3       8     12      15
			//    /   \   /   \     \       \
			//   2     5 7     9    13       16
			//                                 \
			//                                 17
			//                                /
			//                              16.5
            var tree2 = new Tree();          	
            tree2.insert(10);                	
            tree2.insert(6);                 	
            tree2.insert(3);					
            tree2.insert(8);					
            tree2.insert(2);					
            tree2.insert(5);					
            tree2.insert(7);					
            tree2.insert(9);					
            tree2.insert(14);
            tree2.insert(12);
            tree2.insert(15);
            tree2.insert(13);
            tree2.insert(16);
            tree2.insert(17);
			tree2.insert(16.5);
			
            var testTree = new Tree();
            testTree.insert(10);                                                            //          0
            testTree.insert(9);                                                             //        /   \
            testTree.insert(11);                                                            //       0     0
            testTree.insert(12);                                                            //      /       \
            testTree.insert(8);                                                             //     0         0
            testTree.insert(8.7);                                                           //      \
            testTree.insert(8.71);                                                          //       0
            testTree.insert(8.72);                                                          //        \
            testTree.insert(8.6);                                                           //         0
            testTree.insert(8.61);                                                          //        /
            testTree.insert(8.62);                                                          //       0
            assert(findLongestPath(testTree,0,null) === 3, "testtree => 3");                        //      /
            assert(typeof(Tree) === 'function', "function 'Tree' not implemented");         //     0
            assert(findLongestPath(tree,0,null) === 4, "tree => 4");                            //    /
            assert(findLongestPath(tree2,0,null) === 4, "tree2 => 4");                            //   0
        </script>
        <!-- dieser Code zeigt die Implementierung und die Tests an -->
        <script>
            $('pre#ad-4-3-source').html($('#ad-4-3-code').html())
        </script>
		<h3>
			Ergebnis: Die Laufzeit beträgt O(V) und es wird ein zusätzlicher Speicher von O(V) benötigt.
		</h3><br />
        <h3>
            Experimente: Zeitaufwand zur findung des L&auml;ngsten Pfades ohne Richtungswechsel
        </h3>

        <div id="ad-4-3-experiments" style="height: 250px;"></div>
        <script>
            new Morris.Line({
                // ID of the element in which to draw the chart.
                element: 'ad-4-3-experiments',
                // do values relate to dates (time)?
                parseTime: false,
                // Chart data records -- each entry in this array corresponds to a point on
                // the chart.
                data: ad_4_3data,
                // The name of the data record attribute that contains x-values.
                xkey: 'experiment',
                // A list of names of data record attributes that contain y-values.
                ykeys: ['value'],
                // Labels for the ykeys -- will be displayed when you hover over the
                // chart.
                labels: ['Ben&ouml;tigte Zeit']
            });
        </script>
        <h3>
            Experimente: Platzaufwand zur findung des L&auml;ngsten Pfades ohne Richtungswechsel
        </h3>

        <div id="ad-4-3-1-experiments" style="height: 250px;"></div>
        <script>
            new Morris.Line({
                // ID of the element in which to draw the chart.
                element: 'ad-4-3-1-experiments',
                // do values relate to dates (time)?
                parseTime: false,
                // Chart data records -- each entry in this array corresponds to a point on
                // the chart.
                data: ad_4_3_1data,
                // The name of the data record attribute that contains x-values.
                xkey: 'experiment',
                // A list of names of data record attributes that contain y-values.
                ykeys: ['value'],
                // Labels for the ykeys -- will be displayed when you hover over the
                // chart.
                labels: ['Ben&ouml;tigte Speicherplatz']
            });
        </script>
        
       <!-- Aufgabe 4 -->
<h2>
Aufgabe 4.4 (Längste Pfade mit aufsteigendem Kantengewicht)
</h2>
		<ul>
			<li>Zu berechnen ist die Länge n des längsten Pfades (v0,...,vn) eines gerichteten Graphen G = (V,E) mit Gewichtsfunktion w : E -> R für den gilt, dass die Kantengewichte streng monoton zunehmen:</li>
			<li><br /><img alt="formel4" height="30px" src="formel4.png" width="379px" /></li>
			<li>Der Graph erlaubt Kanten der Form (v,v).</li>
			<li>Die Implementierung soll in O(V + E log(E)) laufen und höchstens O(V + E) zusätzlichen Speicherbedarf haben.</li>
			<li>Da keine Einschränkung darüber getroffen wurde, legen wir fest, dass das die Liste von Kanten per se nach aufsteigendem Kantengewicht sortiert ist.</li>
		</ul>
<br />
<h3>
Implementierung
</h3>
<!-- In diesem Element wird der Inhalt des scripts mit der ID ad-4-4-code angezeigt -->
<pre id="ad-4-4-source"></pre>
<h3>
Testergebnisse
</h3>
<div id="ad-4-4-results"></div>
<!-- Code und Tests hier hin -->
<script id="ad-4-4-code">
  var ad_4_4_data = [];

	// Code
		var counter = 0;

	
	function Graph() {
	
		this.edgesCount = 0;
		this.vertexCount = 0;
		
		this.edges = [];
		this.vertieces = [];
		
		
		this.addEdge = function(edge) {
			this.edges[this.edgesCount] = edge;
			this.edgesCount++;
		}
		
		this.addVertex = function(vertex) {
			this.vertieces[this.vertexCount] = vertex;
			this.vertexCount++;
		}
	
		this.getEdgesOf = function(vertex){
			var resultSet = [];
			for(var i=0; i < this.edgesCount;i++){
				var edge = this.edges[i];
				//console.log(edge.toString());
				if(edge.getSource().equals(vertex))
				{
					resultSet.push(this.edges[i]);
				}
			}
			return resultSet;
		}
		
		
		
	}

	function MyVertex(value){	
		this.value = value;
		this.color = "weis";
		this.vorgaenger = null;
		
		
		this.setAttribute = function(value){
			this.value = value;
		}
		
		this.setColor = function(color) {
			this.color = color;
		}
		
		this.toString = function(){
			return ""+this.value;
		}
		
		this.equals = function(otherVertex){
			if(this.value == otherVertex.value){
				return true;
			}
			return false;
		}
	} 

	function MyEdge(source,target,value) {			
		this.source = source;
		this.target = target;
		this.value = value;
		this.visited = false;
		this.depth = 0;
		
		this.visit = function(){
			this.visited = true;
		}
		
		this.setTarget = function(vertex) {
			this.target = vertex;
		}
		
		this.setSource = function(vertex) {
			this.source = vertex;
		}
	
		this.setWeigth = function(value) {
			this.value = value;
		}	
		
		this.getSource = function(){
			return this.source;
		}

		this.getTarget = function(){
			return this.target;
		}

		this.toString = function(){
			return "("+ source + " -> " + target + " : " +this.value + ")";
		}
	}
		

	// ********************************** HILFSFUNKTIONEN *********************************************
	
	// Sortiert die Werte in einem Array aufsteigend -> [1,2,3,4,5,6,7,8,9,10]

  var counter =0;

  function mergeSort(arr) {
		if (arr.length < 2) return arr;
		
		var mid = Math.floor(arr.length /2);
	  	counter+=1;
		var subLeft = mergeSort(arr.slice(0,mid));
	  	counter+=1;
		var subRight = mergeSort(arr.slice(mid));
		
		return merge(subLeft, subRight);
	}

	// Hilfsfunktion für MergeSort
	function merge(a,b) {
		var result = [];
		while (a.length >0 && b.length >0) {
			counter+=1;

			result.push(a[0].value < b[0].value ? a.shift() : b.shift());
		}
		counter += (a.length? a : b).length;
		return result.concat(a.length? a : b);
	}
	
	// Liefert einen random generierten Integer, der zwischen min (inklusiv) und max (exklusiv) liegt
	function getRandomInt(min, max) {
		return Math.floor(Math.random() * (max - min)) + min;
	}

// Liefert den längsten Pfad mit aufsteigendem Gewicht
	function longestPathWithStrongMonotonIncreasingWeight(graph) {
		counter =0;
		var longestPath = 0;	// Der längste gefundene Weg
		var lastSeenEdge = null;// Die zuletzt betrachtete Kante (Wir dürfen nur streng monoton steigend suchen)

		// 1.) alle Kanten von klein nach groß sortieren
		var edgesSorted = new Array().concat(graph.edges);

		// Den Startknoten suchen. Dieser hängt an der kleinsten Kante.

		//var startVertex = lastSeenEdge.getSource();// F
		//var endVertex = lastSeenEdge.getTarget();

		//Länge zum Vergleichen erstellen
		var v1 = 0;

		//Solange unser sortiertes Edgearray nicht leer ist, soll er immer mit der kürzesten Edge beginnend nach einen kürzesten Pfad suchen.
		while (edgesSorted.length>0) {
			counter++;
		lastSeenEdge = edgesSorted[0];
			//aufrufen der suche nach den kürzesten Pfad
		var v2 = getDepth(graph, lastSeenEdge, 1, edgesSorted);
			//vergleich ob der gefundene längeste Pfad größer ist, als der bisherige längste Pfad.
		if (v1 < v2[0]) v1 = v2[0];
		}
		return v1;
		
	}
	
	function getDepth(graph, edge, depth, edgeList){
		counter++;

		//Target Knoten der Edge erhalten, um weitere Edges zu finden.
		var endVertex = edge.getTarget();
		//Initialisirung einer Variable zum bestimen des Abstandes zum Pfadende.
		var depthTillBeginning = 0;

		//Entfernen der Edge aus der EdgeListe
		var elemIndex = edgeList.indexOf(edge);
		if (elemIndex>-1) {
			edgeList.splice(elemIndex, 1);
		}

		//Sofern die Edge schonmal betrachtet worden ist, gibt sie ihren längsten Weg zu einen Pfadende zurück ohne die Schleife weiter zu durchlaufen.
		if (edge.depth > 0){
			return [depth + edge.depth-1,edge.depth+1];
		}

		//Erhalten aller Nachfolger des Targetknotens im Graphen.
		var edges = graph.getEdgesOf(endVertex);

		//Sichern der Variable depth, da diese im Schleifenaufruf geändert werden könnte!
		var thisDepth = depth;

		//Schleife über alle Nachfolger
		for(var i = 0 ; i < edges.length; i++){
			counter++;
				//Prüfung streng Monoton steigend!
				if (edge.value < edges[i].value) {


					//Ein gefundener Pfad wird weitergegangen
					var currDepth = getDepth(graph, edges[i], thisDepth + 1, edgeList);

					//Überprüfung, ob der gefundene Pfad tiefer ist, als der aktuelle.
					if (currDepth[0] > depth) {

						//Setzen der maximalen Tiefe des gefundenen Pfades
						depth = currDepth[0];

						//Setzen der entfernung zum Pfadende
						depthTillBeginning = currDepth[1]
					}
				}
		}

		//Sofern kein weiterer Pfad gefunden wordne ist, muss es sich um den akutellen tiefsten Pfad handeln, der aus der Schleife hervorgeht.
		//Sollte es sich um eine Endedge handeln (edge, an der es nicht weitergeht), wird die Tiefe bis zum Pfadende auf 1 gesetzt.
		if (depthTillBeginning == 0) depthTillBeginning = 1;
		//In der Edge wird dieser Wert gsichert.
		edge.depth = depthTillBeginning;
		//rückgabe der Tiefe und der entfernung zum Pfadende
		return [depth,depthTillBeginning+1];
	}
	
	 // ****************Tests***********************	
	 //graph1 erstellen
	   // Testgraph 1
  // ---------------------------------------------------
  var graphJan = new Graph();

  var v0 = new MyVertex("0");
  var v1 = new MyVertex("1");
  var v2 = new MyVertex("2");
  var v3 = new MyVertex("3");
  var v4 = new MyVertex("4");
  var v5 = new MyVertex("5");
  var v6 = new MyVertex("6");
  var v7 = new MyVertex("7");
  var v8 = new MyVertex("8");

  var e0 = new MyEdge(v0, v1, 0);
  var e1 = new MyEdge(v1, v2, 1);
  var e2 = new MyEdge(v2, v3, 2);
  var e3 = new MyEdge(v3, v4, 3);
  var e4 = new MyEdge(v6, v4, 2);
  var e5 = new MyEdge(v2, v6, 4);
  var e6 = new MyEdge(v7, v6, 1);
  var e7 = new MyEdge(v6, v5, 6);
  var e8 = new MyEdge(v5, v4, 13);
  var e9 = new MyEdge(v8, v5, 11);
  var e10 = new MyEdge(v0, v8, 10);
  var e11 = new MyEdge(v0, v7, 0);
  var e12 = new MyEdge(v8, v7, 2);

  // Add Vertices
  graphJan.addVertex(v0);
  graphJan.addVertex(v1);
  graphJan.addVertex(v2);
  graphJan.addVertex(v3);
  graphJan.addVertex(v4);
  graphJan.addVertex(v5);
  graphJan.addVertex(v6);
  graphJan.addVertex(v7);
  graphJan.addVertex(v8);

  // Add Edges
  graphJan.addEdge(e0);
  graphJan.addEdge(e1);
  graphJan.addEdge(e2);
  graphJan.addEdge(e3);
  graphJan.addEdge(e4);
  graphJan.addEdge(e5);
  graphJan.addEdge(e6);
  graphJan.addEdge(e7);
  graphJan.addEdge(e8);
  graphJan.addEdge(e9);
  graphJan.addEdge(e10);
  graphJan.addEdge(e11);
  graphJan.addEdge(e12);

  // ------------------------------------------------------


  // Test-Graph 2

  // ------------------------------------------------------
  var graph2Jan = new Graph();

  var vert1 = new MyVertex("A");
  var vert2 = new MyVertex("B");
  var vert3 = new MyVertex("C");
  var vert4 = new MyVertex("D");

  var e1 = new MyEdge(vert1, vert2, 1);
  var e2 = new MyEdge(vert2, vert3, 1);
  var e3 = new MyEdge(vert3, vert4, 1);
  var e4 = new MyEdge(vert4, vert1, 1);

  graph2Jan.addVertex(vert1);
  graph2Jan.addVertex(vert2);
  graph2Jan.addVertex(vert3);
  graph2Jan.addVertex(vert4);

  graph2Jan.addEdge(e1);
  graph2Jan.addEdge(e2);
  graph2Jan.addEdge(e3);
  graph2Jan.addEdge(e4);

  // --------------------------------------------------------

  // Testgraph 3
  // -------------------------------------------------------

  var graph3Jan = new Graph();

  var vert1 = new MyVertex("A");
  var vert2 = new MyVertex("B");
  var vert3 = new MyVertex("C");

  var e1 = new MyEdge(vert1, vert2, 0);
  var e2 = new MyEdge(vert2, vert2, 1);
  var e3 = new MyEdge(vert2, vert3, 2);

  graph3Jan.addVertex(vert1);
  graph3Jan.addVertex(vert2);
  graph3Jan.addVertex(vert3);

  graph3Jan.addEdge(e1);
  graph3Jan.addEdge(e2);
  graph3Jan.addEdge(e3);

  // --------------------------------------------------------

  // Testgraph 4
  // ---------------------------------------------------------

  var graph4Jan = new Graph();

  var vert1 = new MyVertex("A");
  var vert2 = new MyVertex("B");
  var vert3 = new MyVertex("C");
  var vert4 = new MyVertex("D");
  var vert5 = new MyVertex("E");
  var vert6 = new MyVertex("F");

  graph4Jan.addVertex(vert1);
  graph4Jan.addVertex(vert2);
  graph4Jan.addVertex(vert3);
  graph4Jan.addVertex(vert4);
  graph4Jan.addVertex(vert5);
  graph4Jan.addVertex(vert6);

  var edge1 = new MyEdge(vert1, vert2, 1);
  var edge2 = new MyEdge(vert2, vert3, 2);
  var edge3 = new MyEdge(vert3, vert4, 0);
  var edge4 = new MyEdge(vert5, vert6, 5);

  graph4Jan.addEdge(edge1);
  graph4Jan.addEdge(edge2);
  graph4Jan.addEdge(edge3);
  graph4Jan.addEdge(edge4);


  // --------------------------------------------------------
 
	 var graf_henning = new Graph();
		
		//Knoten erstellen
		var vertex0 = new MyVertex('V0');
		var vertex1 = new MyVertex('V1');
		var vertex2 = new MyVertex('V2');
		var vertex3 = new MyVertex('V3');
		var vertex4 = new MyVertex('V4');
		var vertex5 = new MyVertex('V5');
		var vertex6 = new MyVertex('V6');
		var vertex7 = new MyVertex('V7');
		var vertex8 = new MyVertex('V8');
		var vertex9 = new MyVertex('V9');
		var vertex10 = new MyVertex('V10');
		var vertex11 = new MyVertex('V11');
		var vertex12 = new MyVertex('V12');
		var vertex13 = new MyVertex('V13');
		var vertex14 = new MyVertex('V14');
		
		graf_henning.addVertex(vertex0);
		graf_henning.addVertex(vertex1);
		graf_henning.addVertex(vertex2);
		graf_henning.addVertex(vertex3);
		graf_henning.addVertex(vertex4);
		graf_henning.addVertex(vertex5);
		graf_henning.addVertex(vertex6);
		graf_henning.addVertex(vertex7);
		graf_henning.addVertex(vertex8);
		graf_henning.addVertex(vertex9);
		graf_henning.addVertex(vertex10);
		graf_henning.addVertex(vertex11);
		graf_henning.addVertex(vertex12);
		graf_henning.addVertex(vertex13);
		graf_henning.addVertex(vertex14);
		
		graf_henning.addEdge(new MyEdge(vertex1,vertex4,1));
		graf_henning.addEdge(new MyEdge(vertex9,vertex8,30));
		graf_henning.addEdge(new MyEdge(vertex7,vertex5,60));
		graf_henning.addEdge(new MyEdge(vertex4,vertex11,100));
		graf_henning.addEdge(new MyEdge(vertex11,vertex9,2));
		graf_henning.addEdge(new MyEdge(vertex1,vertex3,2));
		graf_henning.addEdge(new MyEdge(vertex2,vertex0,2));
		graf_henning.addEdge(new MyEdge(vertex13,vertex12,5));
		graf_henning.addEdge(new MyEdge(vertex13,vertex8,1));
		graf_henning.addEdge(new MyEdge(vertex3,vertex1,5));
		graf_henning.addEdge(new MyEdge(vertex4,vertex7,5));
		graf_henning.addEdge(new MyEdge(vertex5,vertex4,10));
		graf_henning.addEdge(new MyEdge(vertex11,vertex4,10));
		graf_henning.addEdge(new MyEdge(vertex12,vertex8,7));
		graf_henning.addEdge(new MyEdge(vertex2,vertex1,8));
		graf_henning.addEdge(new MyEdge(vertex10,vertex2,8));
		graf_henning.addEdge(new MyEdge(vertex6,vertex5,9));
		graf_henning.addEdge(new MyEdge(vertex12,vertex6,10));
		graf_henning.addEdge(new MyEdge(vertex6,vertex10,11));
		graf_henning.addEdge(new MyEdge(vertex3,vertex5,13));
		graf_henning.addEdge(new MyEdge(vertex3,vertex6,16));
		graf_henning.addEdge(new MyEdge(vertex13,vertex11,17));
		graf_henning.addEdge(new MyEdge(vertex2,vertex3,19));
		graf_henning.addEdge(new MyEdge(vertex10,vertex6,19));
		graf_henning.addEdge(new MyEdge(vertex9,vertex4,20));
		graf_henning.addEdge(new MyEdge(vertex1,vertex0,3));
		graf_henning.addEdge(new MyEdge(vertex7,vertex12,3));
		graf_henning.addEdge(new MyEdge(vertex11,vertex0,4));
		graf_henning.addEdge(new MyEdge(vertex9,vertex13,4));
		graf_henning.addEdge(new MyEdge(vertex3,vertex10,20));
		graf_henning.addEdge(new MyEdge(vertex14,vertex14,200));

		
		
	 var  graph = new Graph();
	 var ver1 = new MyVertex("A");
	 var ver2 = new MyVertex("B");
	 var ver3 = new MyVertex("C");
	 var ver4 = new MyVertex("D");
	 
	 graph.addVertex(ver1);
	 graph.addVertex(ver2);
	 graph.addVertex(ver3);
	 graph.addVertex(ver4);
	 
	 graph.addEdge(new MyEdge(ver1,ver2,1));
	 graph.addEdge(new MyEdge(ver2,ver3,1));
	 graph.addEdge(new MyEdge(ver3,ver4,1));
	 graph.addEdge(new MyEdge(ver4,ver1,1));
	 
	 assert(1 == longestPathWithStrongMonotonIncreasingWeight(graph), "1 == longestPathWithStrongMonotonIncreasingWeight(graph)") ;
	 assert(6 == longestPathWithStrongMonotonIncreasingWeight(graf_henning), "6 == longestPathWithStrongMonotonIncreasingWeight(graf_henning)") ;
	  assert(longestPathWithStrongMonotonIncreasingWeight(graphJan)==5,"longestPathWithStrongMonotonIncreasingWeight(graphJan)==5");
	  assert(longestPathWithStrongMonotonIncreasingWeight(graph2Jan)==1,"longestPathWithStrongMonotonIncreasingWeight(graph2Jan)==1");
	  assert(longestPathWithStrongMonotonIncreasingWeight(graph2Jan)==1,"ongestPathWithStrongMonotonIncreasingWeight(graph2Jan)==1");
	  assert(longestPathWithStrongMonotonIncreasingWeight(graph3Jan)==3,"longestPathWithStrongMonotonIncreasingWeight(graph3Jan)==3");
	  assert(longestPathWithStrongMonotonIncreasingWeight(graph4Jan)==2,"longestPathWithStrongMonotonIncreasingWeight(graph4Jan)==2");

	 
	 
	
	
	 // ********* Random Graphen Erstellen ****************
	 
	 // 20 Knoten, mit 30 Kanten
	 var anzahlKnoten = 20;
	 var anzahlKanten = 30;
	 
	 var graph = new Graph(); // Der Graph
	 
	 for(var i=0;i<anzahlKnoten;i++){ // Die Knoten
		var vertex1 = new MyVertex(i+1);
		graph.addVertex(vertex1);
	 }

  	var graph2 = new Graph();

  {
	  var vert1 = new MyVertex("A");
	  var vert2 = new MyVertex("B");
	  var vert3 = new MyVertex("C");
	  var vert4 = new MyVertex("D");
	  var vert5 = new MyVertex("E");
	  var vert6 = new MyVertex("F");
	  var vert7 = new MyVertex("Q");
	  graph2.addVertex(vert1);
	  graph2.addVertex(vert2);
	  graph2.addVertex(vert3);
	  graph2.addVertex(vert4);
	  graph2.addVertex(vert5);
	  graph2.addVertex(vert6);
	  graph2.addVertex(vert7);

	  graph2.addEdge(new MyEdge(vert1,vert2,10));
	  graph2.addEdge(new MyEdge(vert3,vert1,9));
	  graph2.addEdge(new MyEdge(vert6,vert1,9));
	  graph2.addEdge(new MyEdge(vert5,vert6,8));
	  graph2.addEdge(new MyEdge(vert4,vert5,7));
	  graph2.addEdge(new MyEdge(vert4,vert7,5));
	  graph2.addEdge(new MyEdge(vert3,vert4,4));
	  graph2.addEdge(new MyEdge(vert1,vert3,5));
	  graph2.addEdge(new MyEdge(vert4,vert6,6));
	  graph2.addEdge(new MyEdge(vert6,vert3,3));
	  graph2.addEdge(new MyEdge(vert5,vert1,4));

  }

	 
	 for(var i = 0; i < anzahlKanten;i++){ // Die Kanten
		var randomVertex1 = getRandomInt(0,graph.vertexCount);
		var randomVertex2 = getRandomInt(0,graph.vertexCount);
		graph.addEdge(new MyEdge(graph.vertieces[randomVertex1],graph.vertieces[randomVertex2],i+1));		
	 }
	 
	 
	 console.log("Anzahl Knoten im Graph: " + graph.vertexCount);
	 console.log("Anzahl Kanten im Graph: " + graph.edgesCount);
	 console.log("Alle Knoten: " + graph.vertieces);
	 
	 console.log("Kanten: " + graph.edges);
	 console.log("Kanten sortiert: " + mergeSort(graph.edges));

	 console.log("Ein Knoten: " + graph.vertieces[0]);
	 console.log("Eine Kante: " + graph.edges[0]);
	 graph.getEdgesOf(graph.vertieces[0]);
	 console.log("Iwas " + longestPathWithStrongMonotonIncreasingWeight(graph2)+ " Countaaaa: " + counter);
	 console.log("Iwas " + longestPathWithStrongMonotonIncreasingWeight(graph)+ " Countaaaa: " + counter);
	 //console.log("Kanten von Vertex(1): " + graph.getEdgesOf(graph.vertieces[0]));	 

	 
	 
	//assert(9 === graph.dSearch(), "9 == graph.dSearch()"); 
	//assert(null != graph.dSearch(), "null != graph.dSearch()");  
	  
	 //******************Experimente************************

  {
	var graph3 = new Graph();

		var anzahl = 200;

	  for ( i = 0 ; i < anzahl ; i++ ){
		  var vertex1 = new MyVertex(i+1);
		  graph3.addVertex(vertex1);
	  }

	  var randomVertex1 = getRandomInt(0, graph3.vertexCount);
	  var randomVertex2 = getRandomInt(0, graph3.vertexCount);
	  graph3.addEdge(new MyEdge(graph3.vertieces[randomVertex1], graph3.vertieces[randomVertex2], i + 1));

	  for ( i = 0; i < anzahl*3 ; i++) {
		  var randomVertex1 = getRandomInt(0, graph3.vertexCount);
		  var randomVertex2 = getRandomInt(0, graph3.vertexCount);
		  graph3.addEdge(new MyEdge(graph3.vertieces[randomVertex1], graph3.vertieces[randomVertex2], i + 1));
		  longestPathWithStrongMonotonIncreasingWeight(graph3);
		  ad_4_4_data.push({
			  experiment : graph3.edges.length,
			  value : counter
		  });
	  }
  }

	
	

  // Tests

</script>
<!-- dieser Code zeigt die Implementierung und die Tests an -->
<script>
$('pre#ad-4-4-source').html($('#ad-4-4-code').html())
</script><br />
<h3>
	Ergebnis: Die Laufzeit beträgt O(E) und hat einen Speicherbedarf von O(V+E).
</h3>

<h2>"BeispielGraph" == graf_Henning</h2>
<img alt="Beispielgraph" height="600px" src="adp44.jpg" width="1000px" />
<br />

<h3>
Experimente
</h3>

<div id="ad-4-4-experiments" style="height: 250px;"></div>
<script>
new Morris.Line({
  // ID of the element in which to draw the chart.
  element: 'ad-4-4-experiments',
  // do values relate to dates (time)?
  parseTime: false,
  // Chart data records -- each entry in this array corresponds to a point on
  // the chart.
  data: ad_4_4_data,
  // The name of the data record attribute that contains x-values.
  xkey: 'experiment',
  // A list of names of data record attributes that contain y-values.
  ykeys: ['value'],
  // Labels for the ykeys -- will be displayed when you hover over the
  // chart.
  labels: ['Value']
});
</script>
     
    </body>
</html>