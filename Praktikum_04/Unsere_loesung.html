<!DOCTYPE html>
<html>
    <head>
		<meta charset="utf-8">
        <title>L&ouml;sungsblatt Aufgabe 4</title>
        <!-- morris graph lib -->
        <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/morris.js/0.5.1/morris.css">
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/morris.js/0.5.1/morris.min.js"></script>
        <!-- LaTeX-style equations -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- tests -->
        <script type="text/javascript">
            function assert(value, desc) {
                var li = document.createElement("li");
                li.style.color = value ? "green" : "red";
                li.appendChild(document.createTextNode(desc));
                var list = document.getElementById("results");
                if (!list) {
                    list = document.createElement("div");
                    document.body.appendChild(list);
                }
                list.appendChild(li);
            }

            var Preconditions = {
                checkArgument: function(condition, message) {
                    if (!condition) {
                        throw Error('IllegalArgumentException: ' + (message || ''));
                    }
                }
            };

            var counter = 0;
            var counterTime = 0;

            function count() {counter++;}

            function resetCounter() {counter = 0;}

            function getCounter() {return counter;}

            function countTime() {counterTime++;}

            function resetCounterTime() {counterTime = 0;}

            function getCounterTime() {return counterTime;}

        </script>
    </head>
    <body>
        <h2 id="title">Aufgabe 4 <br></br> Dimitri Meier, Saeed Shanidar,<br /></h2>
        <h2>Aufgabe 4.1 (Summenpaare)</h2>
        <p>
        Gegeben sei eine Sequenz S von ganzen Zahlen und eine ganze Zahl K. Zu berechnen ist die
        Anzahl der Paare von Elementen (P;Q) aus S für die gilt:
        P + Q = K
        </p>
        <p>
        Beispiel: Bei der Eingabe sumPairs([1,4,3,7,2,2],5) existieren 4 Paare => (1,4),(4,1),(3,2),(2,3)
        </p>
        <h3>
        Implementierung
        </h3>
        <!-- In diesem Element wird der Inhalt des scripts mit der ID ad-1-1-results angezeigt -->
        <pre id="ad-1-1-source"></pre>
        <h3>
        Testergebnisse
        </h3>
        <div id="ad-1-1-results"></div>

        <!-- Code und Tests hier hin -->
        <script id="ad-1-1-code">
          var ad_1_1_data = [];

          var counter = 0; // Zählvariable zur Laufzeitmessung
          
          // Code
        	function mergeSort (arr) {    
        		if (arr.length < 2) return arr;
        		
        		var mittle = Math.floor(arr.length /2);
        		var teilLinks = mergeSort(arr.slice(0,mittle));
        		var teilRecht = mergeSort(arr.slice(mittle));
        		
        		return merge(teilLinks, teilRecht);
        	}

        	function merge (links, rechts) {
        		var ergebnis = [];
        		while (links.length >0 && rechts.length >0)
        			ergebnis.push(links[0] < rechts[0]? links.shift() : rechts.shift());
        		return ergebnis.concat(links.length? links : rechts);
        	}
          
        	/*
        		seq, Die zu durchsuchende Sequenz
        		value, Der Wert, der überprüft werden soll
        		@return Anzahl der summenpaare in seq, aus denen man den value bilden kann. 
        	*/
        	function sumPairs(seq,value)
        	{
        		var i = 0;
                var ergebnis = 0;
        		var sortierteSeq = mergeSort(seq);
        		var j = sortierteSeq.length-1;
        		// Die erste for-Schleife läuft in O(seq)
        		while(i < j){
        			counter++;
        			var sumVal = sortierteSeq[i] + sortierteSeq[j];
        			
        			if(sumVal == value){
        				
        				if(sortierteSeq[i] == sortierteSeq[j]){
        					ergebnis++;
        				}
        				else{
        					ergebnis+=2;
        				}
        				
        				var k = i;

        				while(i < j && sortierteSeq[k] == sortierteSeq[i]){
        					counter++;
        					i++;
        				}
        			}
        			else if(sumVal > value) { j--; }

        			else if(sumVal < value) { i++; }
        		}
        		return ergebnis;
        	}

                /*****************************TESTS-ANFANG********************************/
        	
        	var array1 = new Array(10);
        	for(var i=0; i < array1.length;i++){
        		array1[i] = i+1;
        	}
        	
            var array2 = new Array(4,4,4);

        	var array3 = new Array(0,0,2,2,3,3,3,5);
        	
        	assert(4 == sumPairs(array1,5),"([1,2,3,4,5,6,7,8,9,10],5) --> 5 Möglichkeiten ");
        	assert(2 == sumPairs(array3,3),"([0,0,2,2,3,3,3,5],3) --> 3 Möglichkeiten"); 
        	assert(1 == sumPairs(array2,8),"([4,4,4],8) --> 1 Möglichkeit"); 
        	assert(0 == sumPairs(array1,20),"([1,2,3,4,5,6,7,8,9,10],20) --> 0 Möglichkeiten");

        	
        	// Experimente 
        	for(i = 0; i < 100; i ++)
        	{
        		var array3 = new Array(i+1); // Array = [1..100]
        		for(var i=0; i < array3.length; i++){
        			array3[i] = i+1;
        		}
        		counter=0;
        		sumPairs(array3,i+1);
        		ad_1_1_data.push({
        		  experiment : i+1,
        		  value : counter
        		  });
        	}
        	
        </script>
        <!-- dieser Code zeigt die Implementierung und die Tests an -->
        <script>
        $('pre#ad-1-1-source').html($('#ad-1-1-code').html())
        </script>
        <h3>Ergebnis: Laufzeit vom Algorithmus O(|S| log(|S|))</h3>

                      Es wird in der Berechnung  O(|S|) angezeigt, da das Array sortiert werden muss.<br>
                      Dies erfolgt mittles MergeSort O(|S|log(|S|)).<br>
                      Daraus folgt die Laufzeit von O(|S|log(|S|)).<br>
        			  Die Laufzeit ist Abhängig von der Größe der Sequenz.<br>
        	
        			  
        
        <br />
                <h3>
                    Experiment: Zeitaufwand vom Algorithmus sumPairs(seq,value)
                </h3>

        <div id="ad-1-1-experiments" style="height: 250px;"></div>
        <script>
        new Morris.Line({
          // ID of the element in which to draw the chart.
          element: 'ad-1-1-experiments',
          // do values relate to dates (time)?
          parseTime: false,
          // Chart data records -- each entry in this array corresponds to a point on
          // the chart.
          data: ad_1_1_data,
          // The name of the data record attribute that contains x-values.
          xkey: 'experiment',
          // A list of names of data record attributes that contain y-values.
          ykeys: ['value'],
          // Labels for the ykeys -- will be displayed when you hover over the
          // chart.
          labels: ['Value']
        });
        </script>





        <!-- Aufgabe 2 -->
        <h2>
            Aufgabe 4.2 (Mittelpunkte)
        </h2>

            <br>
            Gegeben sei eine Sequenz seq von ganzen Zahlen. Zu berechnen ist ein Index i f&uuml;r den gilt,  <br>
            dass die Summe der Elemente links gleich der Summe der Elemente rechts von i ist: <h4>$\sum\nolimits_{0 \leq j < i}$ S[j] = $\sum\nolimits_{i < k < |S|}$ S[k]</h4>
            Der R&uuml;ckgabewert -1 zeigt an, dass es keinen solchen Index gibt. <br>
            Die Implementierung soll in O(|S|) laufen und h&ouml;chstens O(|S|) zus&auml;tzlichen Speicherbedarf haben.
        <h3>
            Implementierung
        </h3>
        <!-- In diesem Element wird der Inhalt des scripts mit der ID ad-1-2-code angezeigt -->
        <pre id="ad-4-2-source"></pre>
        <h3>
            Testergebnisse
        </h3>
        <div id="ad-4-2-results"></div>
        <!-- Code und Tests hier hin -->
        <script id="ad-4-2-code">
            resetCounter();
            resetCounterTime();
            var ad_4_2data = [];
            var ad_4_2_1data = [];


            function mittelpunkte(seq) {
                Preconditions.checkArgument(Array.isArray(seq), 'seq ist kein Array');

                if(seq.length < 3) {
                    return -1;
                }
                var links = seq[0];   count();
                var rechts = 0;       count();

                for(i = 2; i < seq.length; i++) {
                    rechts += seq[i];      
                    countTime();
                }

                for(i = 1; i < seq.length; i++) {
                    if(links == rechts) {
                        return i;
                    }
                    links += seq[i];       
                    rechts -= seq[i+1];    
                    countTime();
                }
                return -1;
            }


            // Testaufbau
            var testArrayMittelpunkte = [];
            for(var i = 0; i < 100; i ++) {
                testArrayMittelpunkte.push((Math.random() * i) + 1);
                mittelpunkte(testArrayMittelpunkte);
                ad_4_2data.push({
                    experiment : i,
                    value : getCounterTime()
                });

                resetCounterTime();
                mittelpunkteSpace(i,getCounter());
                resetCounter();
            }

            function mittelpunkteSpace(i,space) {
                ad_4_2_1data.push({
                    experiment : i,
                    value : space
                });
            }

            // Tests
            assert(mittelpunkte([1,2,3,5,3,2,1]) === 3, "[1,2,3,5,3,2,1] --> 3");
            assert(mittelpunkte([-1,-2,-3,5,-3,-2,-1]) === 3, "[1,2,3,5,3,2,1] --> 3");
            assert(mittelpunkte([]) === -1, "[] --> -1");
            assert(mittelpunkte([1]) === -1, "[1] --> -1");
            assert(mittelpunkte([1,2]) === -1, "[1,2] --> -1");
            assert(mittelpunkte([1,3,5,9,4,2,3]) === 3, "[1,3,5,9,4,2,3] --> 3");
            assert(mittelpunkte([1,2,3,5,5,2,1]) === -1, "[1,2,3,5,5,2,1] --> -1");
            assert(mittelpunkte([-1,-2,-3,5,1,2,3]) === -1, "[-1,-2,-3,5,1,2,3] --> -1");
            assert(mittelpunkte([-1,-2,-3,5,-6]) === 3, "[-1,-2,-3,5,-6] --> 3");
            assert(mittelpunkte([1,1,1]) === 1, "[1,1,1] --> 1");
            assert(mittelpunkte([0,0,0,0,0,0,0,0]) === 1, "[0,0,0,0,0,0,0,0] --> 1");
            assert(mittelpunkte([1,2,3,5,3,2,1,2,3,3]) === 4, "[1,2,3,5,3,2,1,2,3,3] --> 4");

        </script>
        <!-- dieser Code zeigt die Implementierung und die Tests an -->
        <script>
            $('pre#ad-4-2-source').html($('#ad-4-2-code').html())
        </script>
		
               <h3>Ergebnis: Laufzeit vom Algorithmus O(|S|)</h3>

		       Die Laufzeit ist abhängig von der Größe des Arrays. <br>
               Der Platzbetrag ist in O(1), da wir nur mit zwei Variablen arbeiten.<br><br>


               <h3>Experiment: Zeitaufwand vom Algorithmus mittelpunkte(seq)</h3>


        <div id="ad-4-2-experiments" style="height: 250px;"></div>
        <script>
            new Morris.Line({
                // ID of the element in which to draw the chart.
                element: 'ad-4-2-experiments',
                // do values relate to dates (time)?
                parseTime: false,
                // Chart data records -- each entry in this array corresponds to a point on
                // the chart.
                data: ad_4_2data,
                // The name of the data record attribute that contains x-values.
                xkey: 'experiment',
                // A list of names of data record attributes that contain y-values.
                ykeys: ['value'],
                // Labels for the ykeys -- will be displayed when you hover over the
                // chart.
                labels: ['Ben&ouml;tigte Zeit']
            });
        </script>


        
       
       <!-- Aufgabe 4.3 -->
        <h2>Aufgabe 4.3 (Längste Pfade ohne Richtungswechsel)</h2>
        Gegeben sei ein binärer Baum T = (V, E) und die Funktionen r, l : V ? V ? {nil}, die zu<br>
        einem Knoten das jeweils rechte oder linke Kind bestimmen (nil bedeutet, dass der Knoten<br>
        kein rechtes bzw. linkes Kind hat). Zu berechnen ist die maximale Distanz zwischen den<br>
        Knoten v0, vn für die gilt, dass sie auf einem Pfad von der Wurzel des Baums zu einem Blatt<br>
        liegen und zusätzlich gilt<br><br>
        ?i : 0 ? i < n • l(vi) in (v0, . . . , vn) oder ?i : 0 ? i < n • r(vi) in (v0, . . . , vn)<br><br>
        Die Implementierung soll in O(V ) laufen und höchstens O(V ) zusätzlichen Speicherbedarf
        haben.

        <h3>Implementierung</h3>

        <!-- In diesem Element wird der Inhalt des scripts mit der ID ad-1-2-code angezeigt -->
        <pre id="ad-4-3-source"></pre>

        <h3>Testergebnisse</h3>

        <div id="ad-4-3-results"></div>
        <!-- Code und Tests hier hin -->
        <script id="ad-4-3-code" type="text/javascript">
            var ad_4_3_1_data = [];
            var ad_4_3_2_data = [];
            var ad_4_3_3_data = [];
            
            var counter = 0;

            function istNull(value){
                return value === null;
            }

            function Node(){
                this.value = null;
                this.nodeLinks = null;
                this.nodeRechts = null;


                //Hinzufügen eines neuen Wertes. val ist der neue Wert,
                this.add = function(value) {
                    if (this.value == null){
                        this.value = value;
                    } else {
                        if (value < this.value) {
                            this.addLinks(value);
                        } else {
                            this.addRechts(value);
                        }
                    }
                };


                //Links hinzufügen
                this.addLinks = function (value){
                    if (istNull(this.nodeLinks)){
                        var newValue = new Node();
                        newValue.add(value);
                        this.nodeLinks = newValue;
                    } else {
                        this.nodeLinks.add(value);
                    }
                };

                //rechts hinzufügen
                this.addRechts = function (value){
                    if (istNull(this.nodeRechts)){
                        var newValue = new Node();
                        newValue.add(value);
                        this.nodeRechts = newValue;
                    } else {
                        this.nodeRechts.add(value);
                    }
                };

                this.searchLinks = function (zahl) {
                    counter++;

                    if (istNull(this.nodeLinks)){
                        return zahl+1;
                    }
                    var c1 = this.nodeLinks.searchLinks(zahl+1);
                    var c2 = 0;
                    if (!istNull(this.nodeRechts)){
                        c2 = this.nodeRechts.searchRechts(1);
                    }

                    if (c2 > c1) {
                        return c2;
                    }

                    return c1;
                };

                this.searchRechts = function (zahl) {
                    counter++;
                    if (istNull(this.nodeRechts)){
                        return zahl+1;
                    }

                    var c1 = this.nodeRechts.searchRechts(zahl+1);
                    var c2 = 0;
                    if (!istNull(this.nodeLinks)){
                        c2 = this.nodeLinks.searchLinks(1);
                    }

                    if (c2 > c1){
                        return c2;
                    }

                    return c1;


                };

                this.laengsterPfadOhneRichtungWechsel = function () {
                    counter = 0;

                    var c1 = 0;
                    if (!istNull(this.nodeLinks)){
                        c1 = this.nodeLinks.searchLinks(1);
                    }
                    var c2 = 0;
                    if (!istNull(this.nodeRechts)) {
                        c2 = this.nodeRechts.searchRechts(1);
                    }
                    if ( c1 < c2){
                        return c2;
                    }
                    return c1;

                }

            }

            //Testaufbau
            var testNode = new Node();
            
            testNode.add(50);
            testNode.add(30);
            testNode.add(60);
            testNode.add(55);
            testNode.add(31);
            testNode.add(10);
            testNode.add(1);
            testNode.add(11);
            testNode.add(32);
            testNode.add(33);
            testNode.add(34);
            

            // Tests
            
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 5, "Test in einen Baum. Länge des Pfades: 5.");
            testNode.add(38);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 6, "Element 38 hinzugefügt. Längeste Pfad: 6.");
            testNode.add(56);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 6, "Element 56 hinzugefügt. Längeste Pfad: 6.");
            testNode.add(14);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 6, "Element 14 hinzugefügt. Längeste Pfad: 6.");
            testNode.add(39);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 7, "Element 39 hinzugefügt. Längeste Pfad: 7.");
            testNode.add(62);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 7, "Element 62 hinzugefügt. Längeste Pfad: 7.");
            testNode.add(70);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 7, "Element 70 hinzugefügt. Längeste Pfad: 7.");
            testNode.add(72);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 7, "Element 72 hinzugefügt. Längeste Pfad: 7.");
            testNode.add(80);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 7, "Element 80 hinzugefügt. Längeste Pfad: 7.");
            testNode.add(94);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 7, "Element 94 hinzugefügt. Längeste Pfad: 7.");
            testNode.add(100);
            assert(testNode.laengsterPfadOhneRichtungWechsel() == 8, "Element 100 hinzugefügt. Längeste Pfad: 8.");

            

            //Experimenttest
            var baum1 = new Node();
            for(i =0; i<100;i++){
                var rnd = Math.random()*500;
                baum1.add(rnd);
                baum1.laengsterPfadOhneRichtungWechsel();

                ad_4_3_1_data.push({ experiment: i, value : counter });
            }
            
            var baum2 = new Node();
            for(i =0; i<150;i++){
                var rnd = Math.random()*500;
                baum2.add(rnd);
                baum2.laengsterPfadOhneRichtungWechsel();

                ad_4_3_2_data.push({ experiment: i, value : counter });
            }
            
            var baum3 = new Node();
            for(i =0; i<200;i++){
                var rnd = Math.random()*500;
                baum3.add(rnd);
                baum3.laengsterPfadOhneRichtungWechsel();

                ad_4_3_3_data.push({ experiment: i, value : counter });
            }

        </script>

        <!-- Dieser Code zeigt die Implementierung und die Tests an -->
        <script>$('pre#ad-4-3-source').html($('#ad-4-3-code').html())</script>

        <h3>Beispielgraph 4.3</h3>
        <img alt="Beispielgraph_4_3" src="Beispielgraph_4_3.png" height="600px" src="adp44.jpg" />

        <h3>Experiment Zugriffe auf die Struktur &nbsp; &nbsp; <i>X: Werte, auf die getestet wird &nbsp; &nbsp; Y: Anzahl der Zugriffe </i></h3>
        <div id="ad-4-3-1-experiments" style="height: 250px;"></div>
        
        <script>
            new Morris.Line({
              // ID of the element in which to draw the chart.
              element: 'ad-4-3-1-experiments',
              // do values relate to dates (time)?
              parseTime: false,
              // Chart data records -- each entry in this array corresponds to a point on
              // the chart.
              data: ad_4_3_1_data,
              // The name of the data record attribute that contains x-values.
              xkey: 'experiment',
              // A list of names of data record attributes that contain y-values.
              ykeys: ['value'],
              // Labels for the ykeys -- will be displayed when you hover over the
              // chart.
              labels: ['Value']
            });
        </script>

        <br /><br />
        <div id="ad-4-3-2-experiments" style="height: 250px;"></div>
        
        <script>
            new Morris.Line({
                // ID of the element in which to draw the chart.
                element: 'ad-4-3-2-experiments',
                // do values relate to dates (time)?
                parseTime: false,
                // Chart data records -- each entry in this array corresponds to a point on
                // the chart.
                data: ad_4_3_2_data,
                // The name of the data record attribute that contains x-values.
                xkey: 'experiment',
                // A list of names of data record attributes that contain y-values.
                ykeys: ['value'],
                // Labels for the ykeys -- will be displayed when you hover over the
                // chart.
                labels: ['Value']
            });
        </script>
        
        <br /><br />
        <div id="ad-4-3-3-experiments" style="height: 250px;"></div>
        
        <script>
            new Morris.Line({
                // ID of the element in which to draw the chart.
                element: 'ad-4-3-3-experiments',
                // do values relate to dates (time)?
                parseTime: false,
                // Chart data records -- each entry in this array corresponds to a point on
                // the chart.
                data: ad_4_3_3_data,
                // The name of the data record attribute that contains x-values.
                xkey: 'experiment',
                // A list of names of data record attributes that contain y-values.
                ykeys: ['value'],
                // Labels for the ykeys -- will be displayed when you hover over the
                // chart.
                labels: ['Value']
            });
        </script>
        
        <br /><br /><br /> 
        <hr />
        <br /><br />



                    
         <!-- Aufgabe 4 -->
        <h2>
        Aufgabe 4.4 (Längste Pfade mit aufsteigendem Kantengewicht)
        </h2>
        	Zu berechnen ist die Länge n des längsten Pfades (v0,...,vn) eines gerichteten Graphen G = (V,E) mit Gewichtsfunktion w : E -> R für den gilt, dass die Kantengewichte streng monoton zunehmen:<br>
        	<img alt="formel4" height="30px" src="formel4.png" width="379px" /><br>
        	Der Graph erlaubt Kanten der Form (v,v).<br>
        	Die Implementierung soll in O(V + E log(E)) laufen und höchstens O(V + E) zusätzlichen Speicherbedarf haben.<br>
       
        <h3>
        Implementierung
        </h3>
        <!-- In diesem Element wird der Inhalt des scripts mit der ID ad-4-4-code angezeigt -->
        <pre id="ad-4-4-source"></pre>
        <h3>
        Testergebnisse
        </h3>
        <div id="ad-4-4-results"></div>
        <!-- Code und Tests hier hin -->
        <script id="ad-4-4-code">
            // Code
            var ad_4_4_data = [];
        	var counter = 0;

        	
        	function Graph() {
        		
        		this.edges = [];
        		this.vertices = [];
        		
        		this.addEdge = function(edge)     {	this.edges.push(edge); }
        		this.addVertex = function(vertex) { this.vertices.push(vertex); }
        	
        		this.getOutgoingEdges = function(vertex){
        			var edgeSet = [];
        			for(var i=0; i < this.edges.length; i++){
        				
                        var anEdge = this.edges[i];
        			
        				if(anEdge.isSourceVertex(vertex))
        				{
        					edgeSet.push(anEdge);
        				}
        			}
        			return edgeSet;
        		}	
        	}


        	function OwnVertex(value){	
        		this.value = value;
        		
                this.getValue = function(){ return this.value;}
        		this.equals = function(otherVertex){
        			return this.value == otherVertex.value;
        		}
        	} 


        	function OwnEdge(source,target,value) {			
        		this.source = source;
        		this.target = target;
        		this.value = value;
        		this.depth = 0;
        		
        		this.getSource = function() { return this.source; }
        		this.getTarget = function() { return this.target; }

                this.isSourceVertex = function(vertex){ return this.source.equals(vertex);}
                this.isTargetVertex = function(vertex){ return this.target.equals(vertex);}

                this.getValue = function(){ return this.value;}
        	}
        		

        	// HILFSFUNKTIONEN *********************************************
        	
            var counter =0;

        	function getRandomInt(min, max) {
        		return Math.floor(Math.random() * (max - min)) + min;
        	}

            // Datentyp Pair
            function Pair(key,value){
                this.key = key;
                this.value = value;
            }

            // Liefert den längsten Pfad mit aufsteigendem Gewicht
        	function longestPathWithStrongMonotonIncreasingWeight(graph) {
        		counter =0;
        		var lastSeenEdge = null;// Die zuletzt betrachtete Kante (Wir dürfen nur streng monoton steigend suchen)

        		// 1.) alle Kanten von klein nach groß sortieren
        		var copyOfEdges = new Array().concat(graph.edges);

        		// Den Startknoten suchen. Dieser hängt an der kleinsten Kante.

        		//Länge zum Vergleichen erstellen
        		var longestPath = 0;

        		//Solange unser sortiertes Edgearray nicht leer ist, soll er immer mit der kürzesten Edge beginnend nach einen kürzesten Pfad suchen.
        		while (copyOfEdges.length>0) {
        			counter++;
        		lastSeenEdge = copyOfEdges[0];
        			//aufrufen der suche nach den kürzesten Pfad
        		var pathPair = getDepth(graph, lastSeenEdge, 1, copyOfEdges);
        			//vergleich ob der gefundene längeste Pfad größer ist, als der bisherige längste Pfad.
        		if (longestPath < pathPair.key) longestPath = pathPair.key;
        		}
        		return longestPath;
        		
        	}
        	
        	function getDepth(graph, edge, depth, edgeList){
        		counter++;

        		//Target Knoten der Edge erhalten, um weitere Edges zu finden.
        		var targetVertexOfEdge = edge.getTarget();
        		//Initialisirung einer Variable zum bestimen des Abstandes zum Pfadende.
        		var depthTillBeginning = 0;

        		//Entfernen der Edge aus der EdgeListe
        		var elemIndex = edgeList.indexOf(edge);
        		if (elemIndex>-1) {
        			edgeList.splice(elemIndex, 1);
        		}

        		//Sofern die Edge schonmal betrachtet worden ist, gibt sie ihren längsten Weg zu einen Pfadende zurück ohne die Schleife weiter zu durchlaufen.
        		if (edge.depth > 0){
        			return new Pair(depth + edge.depth-1 , edge.depth+1);
        		}

        		//Erhalten aller Nachfolger des Targetknotens im Graphen.
        		var edges = graph.getOutgoingEdges(endVertex);

        		//Sichern der Variable depth, da diese im Schleifenaufruf geändert werden könnte!
        		var thisDepth = depth;

        		//Schleife über alle Nachfolger
        		for(var i = 0 ; i < edges.length; i++){
        			counter++;
        				//Prüfung streng Monoton steigend!
                        var currentEdge = edges[i];
        				if (edge.getValue() < currentEdge.getValue()) {


        					//Ein gefundener Pfad wird weitergegangen
        					var currentDepthPair = getDepth(graph, currentEdge, thisDepth + 1, edgeList);

        					//Überprüfung, ob der gefundene Pfad tiefer ist, als der aktuelle.
        					if (currentDepthPair.key > depth) {

        						//Setzen der maximalen Tiefe des gefundenen Pfades
        						depth = currentDepthPair.key;

        						//Setzen der entfernung zum Pfadende
        						depthTillBeginning = currentDepthPair.value;
        					}
        				}
        		}

        		//Sofern kein weiterer Pfad gefunden wordne ist, muss es sich um den akutellen tiefsten Pfad handeln, der aus der Schleife hervorgeht.
        		//Sollte es sich um eine Endedge handeln (edge, an der es nicht weitergeht), wird die Tiefe bis zum Pfadende auf 1 gesetzt.
        		if (depthTillBeginning == 0) depthTillBeginning = 1;
        		//In der Edge wird dieser Wert gsichert.
        		edge.depth = depthTillBeginning;
        		//rückgabe der Tiefe und der entfernung zum Pfadende
        		return new Pair(depth,depthTillBeginning+1);
        	}
        	
        	 // Tests***********************	
        	 //graph1 erstellen
        	 // Testgraph 1
          // ---------------------------------------------------
          var graph_1 = new Graph();

          var v0 = new OwnVertex("0");
          var v1 = new OwnVertex("1");
          var v2 = new OwnVertex("2");
          var v3 = new OwnVertex("3");
          var v4 = new OwnVertex("4");
          var v5 = new OwnVertex("5");
          var v6 = new OwnVertex("6");
          var v7 = new OwnVertex("7");
          var v8 = new OwnVertex("8");

          var e0 = new OwnEdge(v0, v1, 0);
          var e1 = new OwnEdge(v1, v2, 1);
          var e2 = new OwnEdge(v2, v3, 2);
          var e3 = new OwnEdge(v3, v4, 3);
          var e4 = new OwnEdge(v6, v4, 2);
          var e5 = new OwnEdge(v2, v6, 4);
          var e6 = new OwnEdge(v7, v6, 1);
          var e7 = new OwnEdge(v6, v5, 6);
          var e8 = new OwnEdge(v5, v4, 13);
          var e9 = new OwnEdge(v8, v5, 11);
          var e10 = new OwnEdge(v0, v8, 10);
          var e11 = new OwnEdge(v0, v7, 0);
          var e12 = new OwnEdge(v8, v7, 2);

          // Add Vertices
          graph_1.addVertex(v0);
          graph_1.addVertex(v1);
          graph_1.addVertex(v2);
          graph_1.addVertex(v3);
          graph_1.addVertex(v4);
          graph_1.addVertex(v5);
          graph_1.addVertex(v6);
          graph_1.addVertex(v7);
          graph_1.addVertex(v8);

          // Add Edges
          graph_1.addEdge(e0);
          graph_1.addEdge(e1);
          graph_1.addEdge(e2);
          graph_1.addEdge(e3);
          graph_1.addEdge(e4);
          graph_1.addEdge(e5);
          graph_1.addEdge(e6);
          graph_1.addEdge(e7);
          graph_1.addEdge(e8);
          graph_1.addEdge(e9);
          graph_1.addEdge(e10);
          graph_1.addEdge(e11);
          graph_1.addEdge(e12);

          // ------------------------------------------------------


          // Test-Graph 2

          // ------------------------------------------------------
          var graph_2 = new Graph();

          var vert1 = new OwnVertex("A");
          var vert2 = new OwnVertex("B");
          var vert3 = new OwnVertex("C");
          var vert4 = new OwnVertex("D");

          var e1 = new OwnEdge(vert1, vert2, 1);
          var e2 = new OwnEdge(vert2, vert3, 1);
          var e3 = new OwnEdge(vert3, vert4, 1);
          var e4 = new OwnEdge(vert4, vert1, 1);

          graph_2.addVertex(vert1);
          graph_2.addVertex(vert2);
          graph_2.addVertex(vert3);
          graph_2.addVertex(vert4);

          graph_2.addEdge(e1);
          graph_2.addEdge(e2);
          graph_2.addEdge(e3);
          graph_2.addEdge(e4);

          // --------------------------------------------------------

          // Testgraph 3
          // -------------------------------------------------------

          var graph_3 = new Graph();

          var vert1 = new OwnVertex("A");
          var vert2 = new OwnVertex("B");
          var vert3 = new OwnVertex("C");

          var e1 = new OwnEdge(vert1, vert2, 0);
          var e2 = new OwnEdge(vert2, vert2, 1);
          var e3 = new OwnEdge(vert2, vert3, 2);

          graph_3.addVertex(vert1);
          graph_3.addVertex(vert2);
          graph_3.addVertex(vert3);

          graph_3.addEdge(e1);
          graph_3.addEdge(e2);
          graph_3.addEdge(e3);

          // --------------------------------------------------------

          // Testgraph 4
          // ---------------------------------------------------------

          var graph_4 = new Graph();

          var vert1 = new OwnVertex("A");
          var vert2 = new OwnVertex("B");
          var vert3 = new OwnVertex("C");
          var vert4 = new OwnVertex("D");
          var vert5 = new OwnVertex("E");
          var vert6 = new OwnVertex("F");

          graph_4.addVertex(vert1);
          graph_4.addVertex(vert2);
          graph_4.addVertex(vert3);
          graph_4.addVertex(vert4);
          graph_4.addVertex(vert5);
          graph_4.addVertex(vert6);

          var edge1 = new OwnEdge(vert1, vert2, 1);
          var edge2 = new OwnEdge(vert2, vert3, 2);
          var edge3 = new OwnEdge(vert3, vert4, 0);
          var edge4 = new OwnEdge(vert5, vert6, 5);

          graph_4.addEdge(edge1);
          graph_4.addEdge(edge2);
          graph_4.addEdge(edge3);
          graph_4.addEdge(edge4);


          // --------------------------------------------------------
          // Testgraph 5
          // ---------------------------------------------------------

         
           var graph_5 = new Graph();
        		
    		//Knoten erstellen
    	   var vertex0 = new OwnVertex('V0');
    	   var vertex1 = new OwnVertex('V1');
    	   var vertex2 = new OwnVertex('V2');
    	   var vertex3 = new OwnVertex('V3');
    	   var vertex4 = new OwnVertex('V4');
    	   var vertex5 = new OwnVertex('V5');
    	   var vertex6 = new OwnVertex('V6');
    	   var vertex7 = new OwnVertex('V7');
    	   var vertex8 = new OwnVertex('V8');
    	   var vertex9 = new OwnVertex('V9');
    	   var vertex10 = new OwnVertex('V10');
    	   var vertex11 = new OwnVertex('V11');
    	   var vertex12 = new OwnVertex('V12');
    	   var vertex13 = new OwnVertex('V13');
    	   var vertex14 = new OwnVertex('V14');
        		
            graph_5.addVertex(vertex0);
            graph_5.addVertex(vertex1);
            graph_5.addVertex(vertex2);
            graph_5.addVertex(vertex3);
            graph_5.addVertex(vertex4);
            graph_5.addVertex(vertex5);
            graph_5.addVertex(vertex6);
            graph_5.addVertex(vertex7);
            graph_5.addVertex(vertex8);
            graph_5.addVertex(vertex9);
            graph_5.addVertex(vertex10);
            graph_5.addVertex(vertex11);
            graph_5.addVertex(vertex12);
            graph_5.addVertex(vertex13);
            graph_5.addVertex(vertex14);
            
            graph_5.addEdge(new OwnEdge(vertex1,vertex4,1));
            graph_5.addEdge(new OwnEdge(vertex9,vertex8,30));
            graph_5.addEdge(new OwnEdge(vertex7,vertex5,60));
            graph_5.addEdge(new OwnEdge(vertex4,vertex11,100));
            graph_5.addEdge(new OwnEdge(vertex11,vertex9,2));
            graph_5.addEdge(new OwnEdge(vertex1,vertex3,2));
            graph_5.addEdge(new OwnEdge(vertex2,vertex0,2));
            graph_5.addEdge(new OwnEdge(vertex13,vertex12,5));
            graph_5.addEdge(new OwnEdge(vertex13,vertex8,1));
            graph_5.addEdge(new OwnEdge(vertex3,vertex1,5));
            graph_5.addEdge(new OwnEdge(vertex4,vertex7,5));
            graph_5.addEdge(new OwnEdge(vertex5,vertex4,10));
            graph_5.addEdge(new OwnEdge(vertex11,vertex4,10));
            graph_5.addEdge(new OwnEdge(vertex12,vertex8,7));
            graph_5.addEdge(new OwnEdge(vertex2,vertex1,8));
            graph_5.addEdge(new OwnEdge(vertex10,vertex2,8));
            graph_5.addEdge(new OwnEdge(vertex6,vertex5,9));
            graph_5.addEdge(new OwnEdge(vertex12,vertex6,10));
            graph_5.addEdge(new OwnEdge(vertex6,vertex10,11));
            graph_5.addEdge(new OwnEdge(vertex3,vertex5,13));
            graph_5.addEdge(new OwnEdge(vertex3,vertex6,16));
            graph_5.addEdge(new OwnEdge(vertex13,vertex11,17));
            graph_5.addEdge(new OwnEdge(vertex2,vertex3,19));
            graph_5.addEdge(new OwnEdge(vertex10,vertex6,19));
            graph_5.addEdge(new OwnEdge(vertex9,vertex4,20));
            graph_5.addEdge(new OwnEdge(vertex1,vertex0,3));
            graph_5.addEdge(new OwnEdge(vertex7,vertex12,3));
            graph_5.addEdge(new OwnEdge(vertex11,vertex0,4));
            graph_5.addEdge(new OwnEdge(vertex9,vertex13,4));
            graph_5.addEdge(new OwnEdge(vertex3,vertex10,20));
            graph_5.addEdge(new OwnEdge(vertex14,vertex14,200));

        		
        	// Testgraph 6
            // ---------------------------------------------------------
	
        	var  graph_6 = new Graph();
        	var ver1 = new OwnVertex("A");
        	var ver2 = new OwnVertex("B");
        	var ver3 = new OwnVertex("C");
        	var ver4 = new OwnVertex("D");
        	
        	graph_6.addVertex(ver1);
        	graph_6.addVertex(ver2);
        	graph_6.addVertex(ver3);
        	graph_6.addVertex(ver4);
        	
        	graph_6.addEdge(new OwnEdge(ver1,ver2,1));
        	graph_6.addEdge(new OwnEdge(ver2,ver3,1));
        	graph_6.addEdge(new OwnEdge(ver3,ver4,1));
        	graph_6.addEdge(new OwnEdge(ver4,ver1,1));
        	
        	
        	assert(longestPathWithStrongMonotonIncreasingWeight(graph_1) == 5,"longestPathWithStrongMonotonIncreasingWeight(graph_1) == 5");
        	assert(longestPathWithStrongMonotonIncreasingWeight(graph_2) == 1,"longestPathWithStrongMonotonIncreasingWeight(graph_2) == 1");
            assert(longestPathWithStrongMonotonIncreasingWeight(graph_3) == 3,"longestPathWithStrongMonotonIncreasingWeight(graph_3) == 3");
            assert(longestPathWithStrongMonotonIncreasingWeight(graph_4) == 2,"longestPathWithStrongMonotonIncreasingWeight(graph_4) == 2");
            assert(longestPathWithStrongMonotonIncreasingWeight(graph_5) == 6,"longestPathWithStrongMonotonIncreasingWeight(graph_5) == 6");
            assert(longestPathWithStrongMonotonIncreasingWeight(graph_6) == 1,"longestPathWithStrongMonotonIncreasingWeight(graph_6) == 1");
        	 
        	 
        	
        	 //Experimente************************
        	var graphExperiment = new Graph();

        		var anzahl = 200;

        	  for ( i = 0 ; i < anzahl ; i++ ){
        		  var vertex1 = new OwnVertex(i+1);
        		  graphExperiment.addVertex(vertex1);
        	  }

        	  var randomVertex1 = getRandomInt(0, graphExperiment.vertices.length);
        	  var randomVertex2 = getRandomInt(0, graphExperiment.vertices.length);
        	  graphExperiment.addEdge(new OwnEdge(graphExperiment.vertices[randomVertex1], graphExperiment.vertices[randomVertex2], i + 1));

        	  for ( i = 0; i < anzahl*3 ; i++) {
        		  var randomVertex1 = getRandomInt(0, graphExperiment.vertices.length);
        		  var randomVertex2 = getRandomInt(0, graphExperiment.vertices.length);
        		  graphExperiment.addEdge(new OwnEdge(graphExperiment.vertices[randomVertex1], graphExperiment.vertices[randomVertex2], i + 1));
        		  longestPathWithStrongMonotonIncreasingWeight(graphExperiment);
        		  ad_4_4_data.push({
        			  experiment : graphExperiment.edges.length,
        			  value : counter
        		  });
        	  }


        </script>
        <!-- dieser Code zeigt die Implementierung und die Tests an -->
        <script>
        $('pre#ad-4-4-source').html($('#ad-4-4-code').html())
        </script><br />
        <h3>
        	Ergebnis: Die Laufzeit beträgt O(E) und hat einen Speicherbedarf von O(V+E).
        </h3>

        <h2>"BeispielGraph" == graph_5</h2>
        <img alt="Beispielgraph" height="600px" src="adp44.jpg" width="1000px" />
        <br />

        <h3>
        Experimente
        </h3>

        <div id="ad-4-4-experiments" style="height: 250px;"></div>
        <script>
        new Morris.Line({
          // ID of the element in which to draw the chart.
          element: 'ad-4-4-experiments',
          // do values relate to dates (time)?
          parseTime: false,
          // Chart data records -- each entry in this array corresponds to a point on
          // the chart.
          data: ad_4_4_data,
          // The name of the data record attribute that contains x-values.
          xkey: 'experiment',
          // A list of names of data record attributes that contain y-values.
          ykeys: ['value'],
          // Labels for the ykeys -- will be displayed when you hover over the
          // chart.
          labels: ['Value']
        });
        </script>
     
    </body>
</html>